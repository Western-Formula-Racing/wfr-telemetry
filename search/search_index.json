{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Slicks","text":"<p>The home baked data pipeline for Western Formula Racing.</p> <p>This package handles:</p> <ol> <li> <p>Data Ingestion: Reliable fetching from InfluxDB 3.0.</p> </li> <li> <p>Movement Detection: Smart filtering of \"Moving\" vs \"Idle\" car states.</p> </li> <li> <p>Sensor Discovery: Tools to explore available sensors on any given race day.</p> </li> </ol>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started: Installation and your first script.</li> <li>API Reference: Detailed function documentation.</li> <li>Advanced Usage: Configuration, Discovery, and Bulk Exports.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/Western-Formula-Racing/wfr-telemetry.git\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import slicks\nfrom datetime import datetime\n\n# 1. Connect (Auto-configured or custom)\nslicks.connect_influxdb3(db=\"WFR25\", influx_url=\"http://influxdb:9000\", influx_token=\"apiv3_your_token\")\n\n# 2. Fetch Data (One-liner)\ndf = slicks.fetch_telemetry(\n    datetime(2025, 9, 28), \n    datetime(2025, 9, 30), \n    \"INV_Motor_Speed\"\n)\n\nprint(df.describe())\n</code></pre> <p>See Getting Started for more details.</p>"},{"location":"advanced_usage/","title":"Advanced Usage &amp; Workflows","text":""},{"location":"advanced_usage/#1-dynamic-sensor-discovery","title":"1. Dynamic Sensor Discovery","text":"<p>Not sure what sensors are available for a specific test day? Don't guess. Use the discovery tool.</p> <pre><code>from slicks import discover_sensors\nfrom datetime import datetime\n\nstart = datetime(2025, 9, 28)\nend = datetime(2025, 9, 30)\n\n# This physically queries the DB to find what tags exist\navailable_sensors = discover_sensors(start, end)\n\nprint(f\"Found {len(available_sensors)} sensors:\")\nfor sensor in available_sensors:\n    print(f\" - {sensor}\")\n</code></pre>"},{"location":"advanced_usage/#2-managing-environments","title":"2. Managing Environments","text":"<p>You often need to switch between <code>Development</code>, <code>Testing</code>, and <code>Production</code> databases, or switch to a local replay server.</p>"},{"location":"advanced_usage/#option-a-environment-variables-best-for-cicd","title":"Option A: Environment Variables (Best for CI/CD)","text":"<p>Set these in your shell or <code>.env</code> file before running python: <pre><code>export INFLUX_URL=\"http://production-server:8086\"\nexport INFLUX_DB=\"Season2026_Final\"\n</code></pre></p>"},{"location":"advanced_usage/#option-b-runtime-configuration-best-for-scriptsnotebooks","title":"Option B: Runtime Configuration (Best for Scripts/Notebooks)","text":"<pre><code>import slicks\n\nslicks.connect_influxdb3(\n    url=\"http://192.168.1.50:9000\",\n    db=\"DynoTest_Day1\"\n)\n</code></pre>"},{"location":"advanced_usage/#3-bulk-export-for-csv-analysis","title":"3. Bulk Export for CSV Analysis","text":"<p>If you need to hand off data to the aerodynamics team who uses Excel/MATLAB, use the bulk fetcher. It handles day-by-day chunking to avoid crashing the computer.</p> <pre><code>from slicks import bulk_fetch_season\n\n# Exports entire date range to a single CSV\nbulk_fetch_season(start, end, output_file=\"full_weekend_data.csv\")\n</code></pre>"},{"location":"advanced_usage/#4-customizing-movement-detection","title":"4. Customizing Movement Detection","text":"<p>If you are analyzing Charging or Static Testing, the default movement filter will hide your data. Disable it:</p> <pre><code># Fetch Battery Current even when car is stopped\ndf = slicks.fetch_telemetry(\n    start, end, \n    signals=\"PackCurrent\", \n    filter_movement=False\n)\n</code></pre>"},{"location":"api_reference/","title":"API Reference","text":"<p>This document details the functions available in the <code>slicks</code> package.</p>"},{"location":"api_reference/#core-functions","title":"Core Functions","text":""},{"location":"api_reference/#slicksconnect_influxdb3","title":"<code>slicks.connect_influxdb3</code>","text":"<p>Updates the global InfluxDB connection settings dynamically.</p> <p><pre><code>slicks.connect_influxdb3(url=None, token=None, org=None, db=None)\n</code></pre> - url (str): The InfluxDB host URL (e.g., <code>\"http://localhost:8086\"</code>). - token (str): Authentication token. - org (str): Organization name (default: <code>\"Docs\"</code>). - db (str): Database/Bucket name (default: <code>\"WFR25\"</code>).</p>"},{"location":"api_reference/#slicksfetch_telemetry","title":"<code>slicks.fetch_telemetry</code>","text":"<p>The primary function to retrieve data. It handles querying, pivoting, resampling, and movement filtering.</p> <pre><code>slicks.fetch_telemetry(start_time, end_time, signals=None, client=None, filter_movement=True)\n</code></pre> <ul> <li>start_time (datetime): Start of the query range.</li> <li>end_time (datetime): End of the query range.</li> <li>signals (str or list[str]): A single sensor name or a list of sensor names to fetch. Defaults to standard configuration if None.</li> <li>client (InfluxDBClient3, optional): An existing client instance (advanced use).</li> <li>filter_movement (bool): If <code>True</code> (default), strips out rows where the car is stationary. If <code>False</code>, returns all raw data.</li> </ul> <p>Returns: <code>pandas.DataFrame</code> indexed by time, with 1-second resolution. Returns <code>None</code> if no data is found.</p>"},{"location":"api_reference/#slicksdiscover_sensors","title":"<code>slicks.discover_sensors</code>","text":"<p>Scans the database to find which sensors actually recorded data during a time period.</p> <pre><code>slicks.discover_sensors(start_time, end_time, chunk_size_days=1)\n</code></pre> <ul> <li>start_time (datetime): Start of scan.</li> <li>end_time (datetime): End of scan.</li> <li>chunk_size_days (int): How many days to query at once (prevents timeouts).</li> </ul> <p>Returns: <code>list[str]</code> of unique sensor names sorted alphabetically.</p>"},{"location":"api_reference/#analysis-tools","title":"Analysis Tools","text":""},{"location":"api_reference/#slicksget_movement_segments","title":"<code>slicks.get_movement_segments</code>","text":"<p>Identifies distinct \"laps\" or driving sessions by detecting gaps in movement.</p> <pre><code>slicks.get_movement_segments(df, speed_column=\"INV_Motor_Speed\", threshold=100.0, max_gap_seconds=60.0)\n</code></pre> <ul> <li>df (pd.DataFrame): DataFrame containing at least a speed column.</li> <li>max_gap_seconds (float): Time in seconds to wait before declaring a new \"segment\" (default: 60s).</li> </ul> <p>Returns: <code>pandas.DataFrame</code> with columns <code>start_time</code>, <code>end_time</code>, <code>duration</code>, <code>state</code> (\"Moving\"/\"Idle\"), and <code>mean_speed</code>.</p>"},{"location":"api_reference/#slicksdetect_movement_ratio","title":"<code>slicks.detect_movement_ratio</code>","text":"<p>Calculates the percentage of time the car was active.</p> <pre><code>slicks.detect_movement_ratio(df, speed_column=\"INV_Motor_Speed\")\n</code></pre> <p>Returns: <code>dict</code> containing <code>total_rows</code>, <code>moving_rows</code>, <code>idle_rows</code>, and <code>movement_ratio</code> (0.0 - 1.0).</p>"},{"location":"example_analysis/","title":"End-to-End Analysis Example","text":"<p>This guide walks through a complete analysis session, from connecting to the database to discovering and visualizing results.</p> <p>Note: You can find the source code for this example here.</p>"},{"location":"example_analysis/#1-setup-connection","title":"1. Setup &amp; Connection","text":"<p>First, we import the necessary libraries and configure our connection.</p> <pre><code>import slicks\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\nimport pandas as pd\n\n# The package auto-loads credentials from environment variables or defaults.\nprint(\"Connecting to Slicks Telemetry Database...\")\n</code></pre> <p>Output: <pre><code>Connecting to Slicks Telemetry Database...\n</code></pre></p>"},{"location":"example_analysis/#2-discovering-sensors","title":"2. Discovering Sensors","text":"<p>Before fetching data, we need to know exactly what sensors were recording during our test session. We'll scan a specific window to see the available signals.</p> <pre><code>start_time = datetime(2025, 9, 28, 20, 20, 0)\nend_time   = datetime(2025, 9, 28, 21, 0, 0)\n\nprint(f\"Scanning for sensors between {start_time} and {end_time}...\")\navailable_sensors = slicks.discover_sensors(start_time, end_time)\n\n# Filter for Inverter (INV) related sensors to narrow our search\ninv_sensors = [s for s in available_sensors if s.startswith(\"INV_\")]\nprint(f\"Found {len(inv_sensors)} Inverter sensors. Examples: {inv_sensors[:5]}\")\n</code></pre> <p>Output: <pre><code>Scanning for sensors between 2025-09-28 20:20:00 and 2025-09-28 21:00:00...\nDiscovering sensors from 2025-09-28 20:20:00 to 2025-09-28 21:00:00...\nDiscovery Complete. Found 342 unique sensors.\nFound 91 Inverter sensors. Examples: ['INV_Analog_Input_1', 'INV_Analog_Input_2', 'INV_Analog_Input_3', 'INV_Analog_Input_4', 'INV_Analog_Input_5']\n</code></pre></p>"},{"location":"example_analysis/#3-fetching-data","title":"3. Fetching Data","text":"<p>Once we've identified our target signals (in this case, <code>INV_Motor_Speed</code> and <code>INV_DC_Bus_Current</code>), we fetch the processed data.</p> <pre><code>target_signals = [\"INV_Motor_Speed\", \"INV_DC_Bus_Current\"]\n\nprint(f\"Fetching data for: {target_signals}...\")\n\n# Fetch 1-second resampled data. \n# We disable filter_movement to capture the full session including startup.\ndf = slicks.fetch_telemetry(start_time, end_time, signals=target_signals, filter_movement=False)\n\nif df is not None:\n    print(f\"Successfully loaded {len(df)} data points.\")\n    print(df.head())\n</code></pre> <p>Output: <pre><code>Fetching data for: ['INV_Motor_Speed', 'INV_DC_Bus_Current']...\nExecuting query for range: 2025-09-28 20:20:00 to 2025-09-28 21:00:00...\nFetched 117 rows.\nSuccessfully loaded 117 data points.\nsignalName           INV_DC_Bus_Current  INV_Motor_Speed\ntime                                                    \n2025-09-28 20:21:27                 0.0              0.0\n2025-09-28 20:21:28                 0.0              0.0\n2025-09-28 20:21:29                 0.0              0.0\n2025-09-28 20:21:30                 0.0              0.0\n2025-09-28 20:21:31                 0.0              0.0\n</code></pre></p>"},{"location":"example_analysis/#4-visualization","title":"4. Visualization","text":"<p>Now we create a dual-axis plot to compare the two signals. We'll use the team's official purple color (<code>#4F2683</code>) for the primary axis.</p> <pre><code>print(\"Generating plot...\")\nwfr_purple = '#4F2683'\n\nfig, ax1 = plt.subplots(figsize=(10, 6))\n\n# Plot Motor Speed on Left Axis\ncolor_speed = wfr_purple\nax1.set_xlabel('Time')\nax1.set_ylabel('Motor Speed (RPM)', color=color_speed, fontsize=12)\nax1.plot(df.index, df['INV_Motor_Speed'], color=color_speed, label='Motor Speed', linewidth=1.2)\nax1.tick_params(axis='y', labelcolor=color_speed)\nax1.grid(True, alpha=0.3)\n\n# Create a second y-axis for Current\nax2 = ax1.twinx()\ncolor_current = 'tab:orange'\nax2.set_ylabel('Inverter DC Bus Current (Amps)', color=color_current, fontsize=12)\nax2.plot(df.index, df['INV_DC_Bus_Current'], color=color_current, label='DC Current', linewidth=1.2, alpha=0.8)\nax2.tick_params(axis='y', labelcolor=color_current)\n\nplt.title(f'Telemetry Analysis: Motor Speed vs Inverter Current\\n{start_time.date()}', fontsize=14, fontweight='bold')\nfig.tight_layout()\nplt.show()\n</code></pre> <p>Output: <pre><code>Generating plot...\n</code></pre></p> <p></p> <p>The plot allows you to visually correlate speed changes with DC current spikes during the test run.</p>"},{"location":"getting_started/","title":"Getting Started with Slicks Telemetry","text":"<p>Welcome to the Slicks Telemetry package. This guide will help you install the package and write your first script to analyze race data.</p>"},{"location":"getting_started/#1-installation","title":"1. Installation","text":""},{"location":"getting_started/#for-users","title":"For Users","text":"<p>To install the latest stable version directly from GitHub:</p> <pre><code>pip install slicks\n</code></pre>"},{"location":"getting_started/#for-developers-contributing","title":"For Developers (Contributing)","text":"<p>If you want to modify the package source code:</p> <pre><code>git clone https://github.com/Western-Formula-Racing/wfr-telemetry.git\ncd wfr-telemetry\npip install -e .\n</code></pre>"},{"location":"getting_started/#2-quick-start","title":"2. Quick Start","text":"<p>Here is the minimal code needed to connect to the database and download data for a specific sensor.</p>"},{"location":"getting_started/#step-1-import-and-configure","title":"Step 1: Import and Configure","text":"<p>The package connects to the InfluxDB database automatically using defaults, but you can configure it explicitly.</p> <pre><code>import slicks\nfrom datetime import datetime\n\n# Optional: Configure manually (or use .env file / defaults)\nslicks.connect_influxdb3(\n    url=\"http://your-influx-server:8086\",\n    token=\"your-token-here\", # Ask Data Lead for your token\n    org=\"Docs\",\n    db=\"WFR25\"\n)\n</code></pre>"},{"location":"getting_started/#step-2-define-time-range","title":"Step 2: Define Time Range","text":"<p>Always use Python's <code>datetime</code> objects.</p> <pre><code>start = datetime(2025, 9, 28, 12, 0, 0) # Sept 28, 2025 at 12:00 PM\nend   = datetime(2025, 9, 28, 14, 0, 0) # Sept 28, 2025 at 02:00 PM\n</code></pre>"},{"location":"getting_started/#step-3-fetch-data","title":"Step 3: Fetch Data","text":"<p>You can request a single sensor or a list of sensors.</p> <pre><code># Fetch Motor Speed\ndf = slicks.fetch_telemetry(start, end, \"INV_Motor_Speed\")\n\nif df is not None:\n    print(df.head())\n    print(f\"Average Speed: {df['INV_Motor_Speed'].mean():.2f}\")\nelse:\n    print(\"No data found for this range.\")\n</code></pre>"},{"location":"getting_started/#3-key-concepts","title":"3. Key Concepts","text":""},{"location":"getting_started/#movement-filtering-default-on","title":"Movement Filtering (Default: On)","text":"<p>By default, <code>fetch_telemetry</code> filters out data when the car is stationary (idling in the pits). This ensures your averages (like average speed or temp) represent driving conditions.</p> <p>To see raw data (including pit/idle time), pass <code>filter_movement=False</code>:</p> <pre><code>df_raw = slicks.fetch_telemetry(start, end, \"INV_Motor_Speed\", filter_movement=False)\n</code></pre>"},{"location":"getting_started/#auto-resampling","title":"Auto-Resampling","text":"<p>By default, data is aligned to a 1-second frequency (<code>1s</code>). This makes it easy to plot multiple sensors on the same graph without worrying about mismatched timestamps.</p> <p>To get raw data without resampling, pass <code>resample=None</code>:</p> <pre><code>df_raw = slicks.fetch_telemetry(start, end, \"INV_Motor_Speed\", resample=None)\n</code></pre> <p>You can also specify a custom frequency using any pandas frequency string:</p> <pre><code># High-resolution data (100ms)\ndf_fast = slicks.fetch_telemetry(start, end, \"INV_Motor_Speed\", resample=\"100ms\")\n\n# Lower resolution (5 seconds)\ndf_slow = slicks.fetch_telemetry(start, end, \"INV_Motor_Speed\", resample=\"5s\")\n</code></pre>"},{"location":"scanner/","title":"Data Availability Scanner","text":"<p>The <code>scan_data_availability</code> function helps you discover when telemetry data exists in your database. It's especially useful in Jupyter notebooks where it provides an interactive, collapsible view of data windows organized by month and day.</p>"},{"location":"scanner/#quick-start","title":"Quick Start","text":"<pre><code>import slicks\nfrom datetime import datetime\n\n# Configure connection first\nslicks.connect_influxdb3(\n    url=\"http://your-server:9000\",\n    token=\"your-token\",\n    db=\"WFR25\"\n)\n\n# Scan for data availability\nresult = slicks.scan_data_availability(\n    start=datetime(2025, 1, 1),\n    end=datetime(2026, 1, 1),\n    timezone=\"America/Toronto\"\n)\n\n# Display interactive view (just type the variable name in Jupyter)\nresult\n</code></pre>"},{"location":"scanner/#interactive-views","title":"Interactive Views","text":""},{"location":"scanner/#collapsible-tree-view","title":"Collapsible Tree View","text":"<p>When you display <code>result</code> in Jupyter, you get a nested, collapsible view:</p> <ul> <li>Months are shown expanded by default</li> <li>Days can be clicked to expand/collapse</li> <li>Time windows show start/end times and row counts</li> </ul> <p></p>"},{"location":"scanner/#calendar-heatmap","title":"Calendar Heatmap","text":"<p>Visualize data density across the year with a GitHub-style calendar:</p> <pre><code>result.calendar_view()\n</code></pre> <p>This creates a 12-month grid where darker green means more data was recorded that day.</p> <p></p>"},{"location":"scanner/#function-reference","title":"Function Reference","text":""},{"location":"scanner/#slicksscan_data_availability","title":"<code>slicks.scan_data_availability</code>","text":"<pre><code>slicks.scan_data_availability(\n    start: datetime,\n    end: datetime,\n    timezone: str = \"UTC\",\n    table: str = None,\n    bin_size: str = \"hour\",\n    include_counts: bool = True,\n    show_progress: bool = True\n) -&gt; ScanResult\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>start</code> <code>datetime</code> required Start of scan range (UTC or timezone-aware) <code>end</code> <code>datetime</code> required End of scan range <code>timezone</code> <code>str</code> <code>\"UTC\"</code> Timezone for display (e.g., <code>\"America/Toronto\"</code>) <code>table</code> <code>str</code> <code>None</code> Table to scan (defaults to <code>\"iox.{INFLUX_DB}\"</code>) <code>bin_size</code> <code>str</code> <code>\"hour\"</code> Granularity: <code>\"hour\"</code> or <code>\"day\"</code> <code>include_counts</code> <code>bool</code> <code>True</code> Include row counts (slightly slower if <code>True</code>) <code>show_progress</code> <code>bool</code> <code>True</code> Show progress bar during scan <p>Returns: <code>ScanResult</code> object with interactive display</p>"},{"location":"scanner/#scanresult-methods","title":"ScanResult Methods","text":""},{"location":"scanner/#to_dict","title":"<code>.to_dict()</code>","text":"<p>Export as nested dictionary:</p> <pre><code>data = result.to_dict()\n# {'2025-01-15': [{'start_utc': '...', 'end_utc': '...', 'row_count': 1500}, ...], ...}\n</code></pre>"},{"location":"scanner/#to_dataframe","title":"<code>.to_dataframe()</code>","text":"<p>Flatten to pandas DataFrame:</p> <pre><code>df = result.to_dataframe()\n</code></pre> date start_utc end_utc start_local end_local row_count duration_hours 2025-01-15 2025-01-15T14:00:00+00:00 2025-01-15T16:00:00+00:00 ... ... 1500 2.0"},{"location":"scanner/#calendar_viewyearnone","title":"<code>.calendar_view(year=None)</code>","text":"<p>Generate a heatmap calendar:</p> <pre><code>fig = result.calendar_view()  # Auto-detects year from data\nfig = result.calendar_view(year=2025)  # Specific year\n</code></pre>"},{"location":"scanner/#properties","title":"Properties","text":"<ul> <li><code>result.days</code> - List of dates with data (e.g., <code>['2025-01-15', '2025-01-16', ...]</code>)</li> <li><code>result.total_rows</code> - Total row count across all windows</li> <li><code>len(result)</code> - Number of days with data</li> </ul>"},{"location":"scanner/#performance-tips","title":"Performance Tips","text":""},{"location":"scanner/#for-large-date-ranges","title":"For Large Date Ranges","text":"<p>Use day-level granularity for faster scans:</p> <pre><code>result = slicks.scan_data_availability(\n    start=datetime(2025, 1, 1),\n    end=datetime(2026, 1, 1),\n    bin_size=\"day\"  # Much faster than \"hour\"\n)\n</code></pre>"},{"location":"scanner/#skip-row-counts","title":"Skip Row Counts","text":"<p>If you only need to know when data exists (not how much):</p> <pre><code>result = slicks.scan_data_availability(\n    start=datetime(2025, 1, 1),\n    end=datetime(2025, 2, 1),\n    include_counts=False  # Faster\n)\n</code></pre>"},{"location":"scanner/#scan-smaller-ranges","title":"Scan Smaller Ranges","text":"<p>For dense months, scan one month at a time:</p> <pre><code>result = slicks.scan_data_availability(\n    start=datetime(2025, 6, 1),\n    end=datetime(2025, 7, 1),\n    timezone=\"America/Toronto\"\n)\n</code></pre>"},{"location":"scanner/#terminal-usage","title":"Terminal Usage","text":"<p>The scanner also works in regular Python scripts with a text-based display:</p> <pre><code>result = slicks.scan_data_availability(...)\nprint(result)\n</code></pre> <p>Output: <pre><code>Data Availability (America/Toronto)\n========================================\n\n\ud83d\udcc6 January 2025 (3 days, 4,500 rows)\n   \ud83d\udcc5 Day 15 (2 windows, 1,500 rows)\n      \u2514\u2500 09:00 \u2192 11:00 (1,200 rows)\n      \u2514\u2500 14:30 \u2192 16:00 (300 rows)\n   \ud83d\udcc5 Day 16 (1 window, 3,000 rows)\n      \u2514\u2500 10:00 \u2192 14:00 (3,000 rows)\n\n========================================\nTotal: 3 days, 4,500 rows\n</code></pre></p>"}]}